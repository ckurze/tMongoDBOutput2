<%@ jet 
	imports="
		org.talend.core.model.process.INode 
		org.talend.core.model.process.ElementParameterParser 
		org.talend.core.model.metadata.IMetadataTable 
		org.talend.designer.codegen.config.CodeGeneratorArgument
		java.util.List
		java.util.Map
	   	org.talend.core.model.process.IConnection    
		org.talend.core.model.process.IConnectionCategory
		org.talend.core.model.process.EConnectionType
		org.talend.core.model.utils.NodeUtil
	" 
%>
	<% 
	CodeGeneratorArgument codeGenArgument = (CodeGeneratorArgument) argument;
	INode node = (INode)codeGenArgument.getArgument();
  	String cid = node.getUniqueName();

    String dbhost   = ElementParameterParser.getValue(node, "__HOST__");
    String dbname   = ElementParameterParser.getValue(node, "__DATABASE__");
    boolean authentication="true".equalsIgnoreCase(ElementParameterParser.getValue(node, "__REQUIRED_AUTHENTICATION__"));
    String authenticationMechanism = ElementParameterParser.getValue(node, "__AUTHENTICATION_MECHANISM__");
    String krbUserPrincipal = ElementParameterParser.getValue(node, "__KRB_USER_PRINCIPAL__");
    String krbRealm = ElementParameterParser.getValue(node, "__KRB_REALM__");
    String krbKdc = ElementParameterParser.getValue(node, "__KRB_KDC__");
    String dbuser   = ElementParameterParser.getValue(node, "__USERNAME__");
    String dbpass   = ElementParameterParser.getValue(node, "__PASSWORD__");
    String mongoPort = ElementParameterParser.getValue(node, "__PORT__");
    String dbport = mongoPort.startsWith("context.") ? "Integer.valueOf(" + mongoPort + ").intValue()" : mongoPort.replace("\"", "");
    String collection=ElementParameterParser.getValue(node, "__COLLECTION__");
    boolean dropExistCollection="true".equalsIgnoreCase(ElementParameterParser.getValue(node,"__DROP_COLLECTION_CREATE__"));
    boolean useExistingConnection = "true".equalsIgnoreCase(ElementParameterParser.getValue(node,"__USE_EXISTING_CONNECTION__"));
    boolean removeRoot="true".equalsIgnoreCase(ElementParameterParser.getValue(node, "__REMOVE_ROOT__"));
    boolean useReplicaSet="true".equalsIgnoreCase(ElementParameterParser.getValue(node, "__USE_REPLICA_SET__"));
    boolean setWriteConcern = "true".equalsIgnoreCase(ElementParameterParser.getValue(node, "__SET_WRITE_CONCERN__"));
    String writeConcern = ElementParameterParser.getValue(node, "__WRITE_CONCERN__");

    boolean setBulkWrite = "true".equalsIgnoreCase(ElementParameterParser.getValue(node, "__SET_BULK_WRITE__"));
    String bulkWriteOperationSize = ElementParameterParser.getValue(node, "__BULK_WRITE_SIZE__");
    String bulkWriteType = ElementParameterParser.getValue(node, "__BULK_WRITE_TYPE__");
    boolean useAuthDB = "true".equalsIgnoreCase(ElementParameterParser.getValue(node, "__SET_AUTHENTICATION_DATABASE__"));
    String authDB = ElementParameterParser.getValue(node, "__AUTHENTICATION_DATABASE__");
    String usedAuthenticationDB = useAuthDB ? authDB : dbname;
    String dataAction = ElementParameterParser.getValue(node,"__DATA_ACTION__");
    boolean queryOptionNoTimeOut;
	String dbversion;
	if(useExistingConnection){
	    String connection = ElementParameterParser.getValue(node, "__CONNECTION__");
        INode connectionNode = NodeUtil.getNodeByUniqueName(node.getProcess(), connection);
        dbversion = ElementParameterParser.getValue(connectionNode, "__DB_VERSION__");
        queryOptionNoTimeOut = "true".equalsIgnoreCase(ElementParameterParser.getValue(connectionNode, "__QUERYOPTION_NOTIMEOUT__"));
    }else{
        dbversion = ElementParameterParser.getValue(node, "__DB_VERSION__");
        queryOptionNoTimeOut = "true".equalsIgnoreCase(ElementParameterParser.getValue(node, "__QUERYOPTION_NOTIMEOUT__"));
    }
    boolean version_3_5_X = "MONGODB_3_5_X".equals(dbversion);
    String objectType = version_3_5_X?"org.bson.Document":"com.mongodb.DBObject";
        // BulkWrite is only supportted on Mongo 2.6+
    final boolean bulkWrite = setBulkWrite & (!"MONGODB_2_5_X".equalsIgnoreCase(dbversion));

    boolean isLog4jEnabled = ("true").equals(ElementParameterParser.getValue(node.getProcess(), "__LOG4J_ACTIVATE__"));
	%>
	int nb_line_<%=cid %> = 0;


				/**
			 * Utility class for transforming net.sf.json.JSON to XML an back.<br>
			 * When transforming net.sf.json.JSONObject and net.sf.json.JSONArray instances to XML, this class will
			 * add hints for converting back to net.sf.json.JSON.<br>
			 * Examples:<br>
			 *
			 * <pre>
			 * net.sf.json.JSONObject json = net.sf.json.JSONObject.fromObject("{\"name\":\"json\",\"bool\":true,\"int\":1}");
			 * String xml = new net.sf.json.xml.XMLSerializer().write( json );
			 * <xmp><o class="object">
			 <name type="string">json</name>
			 <bool type="boolean">true</bool>
			 <int type="number">1</int>
			 </o></xmp>
			 * </pre><pre>
			 * net.sf.json.JSONArray json = net.sf.json.JSONArray.fromObject("[1,2,3]");
			 * String xml = new net.sf.json.xml.XMLSerializer().write( json );
			 * <xmp><a class="array">
			 <e type="number">1</e>
			 <e type="number">2</e>
			 <e type="number">3</e>
			 </a></xmp>
			 * </pre>
			 *
			 * @author Andres Almiray <aalmiray@users.sourceforge.net>; extensions by Christian Kurze (mail@christian-kurze.de) to fix the generation from XML to net.sf.json.JSON
			 */
			class MyXMLSerializer extends net.sf.json.xml.XMLSerializer {
			   private final String[] EMPTY_ARRAY = new String[0];
			   private  final org.apache.commons.logging.Log log = org.apache.commons.logging.LogFactory.getLog( MyXMLSerializer.class );

			   /** the name for an net.sf.json.JSONArray nu.xom.Element */
			   private String arrayName;
			   /** the name for an net.sf.json.JSONArray's element nu.xom.Element */
			   private String elementName;
			   /** list of properties to be expanded from child to parent */
			   private String[] expandableProperties;
			   /** flag to be tolerant for incomplete namespace prefixes */
			   private boolean namespaceLenient;
			   /** java.util.Map of namespaces per element */
			   private java.util.Map namespacesPerElement = new java.util.TreeMap();
			   /** the name for an net.sf.json.JSONObject nu.xom.Element */
			   private String objectName;
			   /** flag for trimming namespace prefix from element name */
			   private boolean removeNamespacePrefixFromElements;
			   /** the name for the root nu.xom.Element */
			   private String rootName;
			   /** java.util.Map of namespaces for root element */
			   private java.util.Map rootNamespace = new java.util.TreeMap();
			   /** flag for skipping namespaces while reading */
			   private boolean skipNamespaces;
			   /** flag for trimming spaces from string values */
			   private boolean trimSpaces;
			   /** flag for adding net.sf.json.JSON types hints as attributes */
			   private boolean typeHintsEnabled;

			   /**
			    * Creates a new net.sf.json.xml.XMLSerializer with default options.<br>
			    * <ul>
			    * <li><code>objectName</code>: 'o'</li>
			    * <li><code>arrayName</code>: 'a'</li>
			    * <li><code>elementName</code>: 'e'</li>
			    * <li><code>typeHinstEnabled</code>: true</li>
			    * <li><code>namespaceLenient</code>: false</li>
			    * <li><code>expandableProperties</code>: []</li>
			    * <li><code>skipNamespaces</code>: false</li>
			    * <li><code>removeNameSpacePrefixFromElement</code>: false</li>
			    * <li><code>trimSpaces</code>: false</li>
			    * </ul>
			    */
			   public MyXMLSerializer() {
			      setObjectName( "o" );
			      setArrayName( "a" );
			      setElementName( "e" );
			      setTypeHintsEnabled( true );
			      setNamespaceLenient( false );
			      setSkipNamespaces( false );
			      setRemoveNamespacePrefixFromElements( false );
			      setTrimSpaces( false );
			      setExpandableProperties( EMPTY_ARRAY );
			   }

			   /**
			    * Adds a namespace declaration to the root element.
			    *
			    * @param prefix namespace prefix
			    * @param uri namespace uri
			    */
			   public void addNamespace( String prefix, String uri ) {
			      addNamespace( prefix, uri, null );
			   }

			   /**
			    * Adds a namespace declaration to an element.<br>
			    * If the elementName param is null or blank, the namespace declaration will
			    * be added to the root element.
			    *
			    * @param prefix namespace prefix
			    * @param uri namespace uri
			    * @param elementName name of target element
			    */
			   public void addNamespace( String prefix, String uri, String elementName ) {
			      if( org.apache.commons.lang.StringUtils.isBlank( uri ) ){
			         return;
			      }
			      if( prefix == null ){
			         prefix = "";
			      }
			      if( org.apache.commons.lang.StringUtils.isBlank( elementName ) ){
			         rootNamespace.put( prefix.trim(), uri.trim() );
			      }else{
			         java.util.Map nameSpaces = (java.util.Map) namespacesPerElement.get( elementName );
			         if( nameSpaces == null ){
			            nameSpaces = new java.util.TreeMap();
			            namespacesPerElement.put( elementName, nameSpaces );
			         }
			         nameSpaces.put( prefix, uri );
			      }
			   }

			   /**
			    * Removes all namespaces declarations (from root an elements).
			    */
			   public void clearNamespaces() {
			      rootNamespace.clear();
			      namespacesPerElement.clear();
			   }

			   /**
			    * Removes all namespace declarations from an element.<br>
			    * If the elementName param is null or blank, the declarations will be
			    * removed from the root element.
			    *
			    * @param elementName name of target element
			    */
			   public void clearNamespaces( String elementName ) {
			      if( org.apache.commons.lang.StringUtils.isBlank( elementName ) ){
			         rootNamespace.clear();
			      }else{
			         namespacesPerElement.remove( elementName );
			      }
			   }

			   /**
			    * Returns the name used for net.sf.json.JSONArray.
			    */
			   public String getArrayName() {
			      return arrayName;
			   }

			   /**
			    * Returns the name used for net.sf.json.JSONArray elements.
			    */
			   public String getElementName() {
			      return elementName;
			   }

			   /**
			    * Returns a list of properties to be expanded from child to parent.
			    */
			   public String[] getExpandableProperties() {
			      return expandableProperties;
			   }

			   /**
			    * Returns the name used for net.sf.json.JSONArray.
			    */
			   public String getObjectName() {
			      return objectName;
			   }

			   /**
			    * Returns the name used for the root element.
			    */
			   public String getRootName() {
			      return rootName;
			   }

			   /**
			    * Returns wether this serializer is tolerant to namespaces without URIs or
			    * not.
			    */
			   public boolean isNamespaceLenient() {
			      return namespaceLenient;
			   }

			   /**
			    * Returns wether this serializer will remove namespace prefix from elements
			    * or not.
			    */
			   public boolean isRemoveNamespacePrefixFromElements() {
			      return removeNamespacePrefixFromElements;
			   }

			   /**
			    * Returns wether this serializer will skip adding namespace declarations to
			    * elements or not.
			    */
			   public boolean isSkipNamespaces() {
			      return skipNamespaces;
			   }

			   /**
			    * Returns wether this serializer will trim leading and trealing whitespace
			    * from values or not.
			    */
			   public boolean isTrimSpaces() {
			      return trimSpaces;
			   }

			   /**
			    * Returns true if net.sf.json.JSON types will be included as attributes.
			    */
			   public boolean isTypeHintsEnabled() {
			      return typeHintsEnabled;
			   }

			   /**
			    * Creates a net.sf.json.JSON value from a XML string.
			    *
			    * @param xml A well-formed xml document in a String
			    * @return a net.sf.json.JSONNull, net.sf.json.JSONObject or net.sf.json.JSONArray
			    * @throws net.sf.json.JSONException if the conversion from XML to net.sf.json.JSON can't be made for
			    *         I/O or format reasons.
			    */
			   public net.sf.json.JSON read( String xml ) {
			      net.sf.json.JSON json = null;
			      try{
			         nu.xom.Document doc = new nu.xom.Builder().build( new java.io.StringReader( xml ) );
			         nu.xom.Element root = doc.getRootElement();
			         if( isNullObject( root ) ){
			            return net.sf.json.JSONNull.getInstance();
			         }
			         String defaultType = getType( root, net.sf.json.xml.JSONTypes.STRING );
			         if( isArray( root, true ) ){
			            json = processArrayElement( root, defaultType );
			         }else{
			            json = processObjectElement( root, defaultType );
			         }
			      }catch( net.sf.json.JSONException jsone ){
			         throw jsone;
			      }catch( Exception e ){
			         throw new net.sf.json.JSONException( e );
			      }
			      return json;
			   }

			   /**
			    * Creates a net.sf.json.JSON value from a java.io.File.
			    *
			    * @param file
			    * @return a net.sf.json.JSONNull, net.sf.json.JSONObject or net.sf.json.JSONArray
			    * @throws net.sf.json.JSONException if the conversion from XML to net.sf.json.JSON can't be made for
			    *         I/O or format reasons.
			    */
			   public net.sf.json.JSON readFromFile( java.io.File file ) {
			      if( file == null ){
			         throw new net.sf.json.JSONException( "java.io.File is null" );
			      }
			      if( !file.canRead() ){
			         throw new net.sf.json.JSONException( "Can't read input file" );
			      }
			      if( file.isDirectory() ){
			         throw new net.sf.json.JSONException( "java.io.File is a directory" );
			      }
			      try{
			         return readFromStream( new java.io.FileInputStream( file ) );
			      }catch( java.io.IOException ioe ){
			         throw new net.sf.json.JSONException( ioe );
			      }
			   }

			   /**
			    * Creates a net.sf.json.JSON value from a java.io.File.
			    *
			    * @param path
			    * @return a net.sf.json.JSONNull, net.sf.json.JSONObject or net.sf.json.JSONArray
			    * @throws net.sf.json.JSONException if the conversion from XML to net.sf.json.JSON can't be made for
			    *         I/O or format reasons.
			    */
			   public net.sf.json.JSON readFromFile( String path ) {
			      return readFromStream( Thread.currentThread()
			            .getContextClassLoader()
			            .getResourceAsStream( path ) );
			   }

			   /**
			    * Creates a net.sf.json.JSON value from an input stream.
			    *
			    * @param stream
			    * @return a net.sf.json.JSONNull, net.sf.json.JSONObject or net.sf.json.JSONArray
			    * @throws net.sf.json.JSONException if the conversion from XML to net.sf.json.JSON can't be made for
			    *         I/O or format reasons.
			    */
			   public net.sf.json.JSON readFromStream( java.io.InputStream stream ) {
			      try{
			         StringBuffer xml = new StringBuffer();
			         java.io.BufferedReader in = new java.io.BufferedReader( new java.io.InputStreamReader( stream ) );
			         String line = null;
			         while( (line = in.readLine()) != null ){
			            xml.append( line );
			         }
			         return read( xml.toString() );
			      }catch( java.io.IOException ioe ){
			         throw new net.sf.json.JSONException( ioe );
			      }
			   }
			   
			   /** 
			    * Remove null values and empty string values
			    */
			   public net.sf.json.JSON removeEmptyAndNullValues(net.sf.json.JSON json) {
				   if (json instanceof net.sf.json.JSONObject) {
					   net.sf.json.JSONObject jsonObject = (net.sf.json.JSONObject) json;
					   gatherKeysToRemove(jsonObject);
				   }
				   
				   return json;
			   }
			   
			   /**
			    * Recursively parse through the net.sf.json.JSON Objects and remove null values / Empty Strings
			    * @param jsonObject
			    * @param keysToRemove
			    */
			   private void gatherKeysToRemove(net.sf.json.JSONObject jsonObject) {
				   java.util.List<Object> keysToRemove = new java.util.ArrayList<>();
				   for (Object o: jsonObject.keySet()) {
					   if (jsonObject.get(o) == null || "null".equals(jsonObject.get(o).toString()) || "".equals(jsonObject.get(o).toString())) {
						   keysToRemove.add(o);
					   }
					   else if (jsonObject.get(o) != null && jsonObject.get(o) instanceof net.sf.json.JSONObject) {
						   gatherKeysToRemove((net.sf.json.JSONObject) jsonObject.get(o)); 
					   }
				   }
				   for (Object o: keysToRemove) {
					   jsonObject.remove(o);
				   }
				   keysToRemove.clear();
					   
			   }
			   

			   /**
			    * Removes a namespace from the root element.
			    *
			    * @param prefix namespace prefix
			    */
			   public void removeNamespace( String prefix ) {
			      removeNamespace( prefix, null );
			   }

			   /**
			    * Removes a namespace from the root element.<br>
			    * If the elementName is null or blank, the namespace will be removed from
			    * the root element.
			    *
			    * @param prefix namespace prefix
			    * @param elementName name of target element
			    */
			   public void removeNamespace( String prefix, String elementName ) {
			      if( prefix == null ){
			         prefix = "";
			      }
			      if( org.apache.commons.lang.StringUtils.isBlank( elementName ) ){
			         rootNamespace.remove( prefix.trim() );
			      }else{
			         java.util.Map nameSpaces = (java.util.Map) namespacesPerElement.get( elementName );
			         nameSpaces.remove( prefix );
			      }
			   }

			   /**
			    * Sets the name used for net.sf.json.JSONArray.<br>
			    * Default is 'a'.
			    */
			   public void setArrayName( String arrayName ) {
			      this.arrayName = org.apache.commons.lang.StringUtils.isBlank( arrayName ) ? "a" : arrayName;
			   }

			   /**
			    * Sets the name used for net.sf.json.JSONArray elements.<br>
			    * Default is 'e'.
			    */
			   public void setElementName( String elementName ) {
			      this.elementName = org.apache.commons.lang.StringUtils.isBlank( elementName ) ? "e" : elementName;
			   }

			   /**
			    * Sets the list of properties to be expanded from child to parent.
			    */
			   public void setExpandableProperties( String[] expandableProperties ) {
			      this.expandableProperties = expandableProperties == null ? EMPTY_ARRAY : expandableProperties;
			   }

			   /**
			    * Sets the namespace declaration to the root element.<br>
			    * Any previous values are discarded.
			    *
			    * @param prefix namespace prefix
			    * @param uri namespace uri
			    */
			   public void setNamespace( String prefix, String uri ) {
			      setNamespace( prefix, uri, null );
			   }

			   /**
			    * Adds a namespace declaration to an element.<br>
			    * Any previous values are discarded. If the elementName param is null or
			    * blank, the namespace declaration will be added to the root element.
			    *
			    * @param prefix namespace prefix
			    * @param uri namespace uri
			    * @param elementName name of target element
			    */
			   public void setNamespace( String prefix, String uri, String elementName ) {
			      if( org.apache.commons.lang.StringUtils.isBlank( uri ) ){
			         return;
			      }
			      if( prefix == null ){
			         prefix = "";
			      }
			      if( org.apache.commons.lang.StringUtils.isBlank( elementName ) ){
			         rootNamespace.clear();
			         rootNamespace.put( prefix.trim(), uri.trim() );
			      }else{
			         java.util.Map nameSpaces = (java.util.Map) namespacesPerElement.get( elementName );
			         if( nameSpaces == null ){
			            nameSpaces = new java.util.TreeMap();
			            namespacesPerElement.put( elementName, nameSpaces );
			         }
			         nameSpaces.clear();
			         nameSpaces.put( prefix, uri );
			      }
			   }

			   /**
			    * Sets wether this serializer is tolerant to namespaces without URIs or not.
			    */
			   public void setNamespaceLenient( boolean namespaceLenient ) {
			      this.namespaceLenient = namespaceLenient;
			   }

			   /**
			    * Sets the name used for net.sf.json.JSONObject.<br>
			    * Default is 'o'.
			    */
			   public void setObjectName( String objectName ) {
			      this.objectName = org.apache.commons.lang.StringUtils.isBlank( objectName ) ? "o" : objectName;
			   }

			   /**
			    * Sets if this serializer will remove namespace prefix from elements when
			    * reading.
			    */
			   public void setRemoveNamespacePrefixFromElements( boolean removeNamespacePrefixFromElements ) {
			      this.removeNamespacePrefixFromElements = removeNamespacePrefixFromElements;
			   }

			   /**
			    * Sets the name used for the root element.
			    */
			   public void setRootName( String rootName ) {
			      this.rootName = org.apache.commons.lang.StringUtils.isBlank( rootName ) ? null : rootName;
			   }

			   /**
			    * Sets if this serializer will skip adding namespace declarations to
			    * elements when reading.
			    */
			   public void setSkipNamespaces( boolean skipNamespaces ) {
			      this.skipNamespaces = skipNamespaces;
			   }

			   /**
			    * Sets if this serializer will trim leading and trealing whitespace from
			    * values when reading.
			    */
			   public void setTrimSpaces( boolean trimSpaces ) {
			      this.trimSpaces = trimSpaces;
			   }

			   /**
			    * Sets wether net.sf.json.JSON types will be included as attributes.
			    */
			   public void setTypeHintsEnabled( boolean typeHintsEnabled ) {
			      this.typeHintsEnabled = typeHintsEnabled;
			   }

			   /**
			    * Writes a net.sf.json.JSON value into a XML string with UTF-8 encoding.<br>
			    *
			    * @param json The net.sf.json.JSON value to transform
			    * @return a String representation of a well-formed xml document.
			    * @throws net.sf.json.JSONException if the conversion from net.sf.json.JSON to XML can't be made for
			    *         I/O reasons.
			    */
			   public String write( net.sf.json.JSON json ) {
			      return write( json, null );
			   }

			   /**
			    * Writes a net.sf.json.JSON value into a XML string with an specific encoding.<br>
			    * If the encoding string is null it will use UTF-8.
			    *
			    * @param json The net.sf.json.JSON value to transform
			    * @param encoding The xml encoding to use
			    * @return a String representation of a well-formed xml document.
			    * @throws net.sf.json.JSONException if the conversion from net.sf.json.JSON to XML can't be made for
			    *         I/O reasons or the encoding is not supported.
			    */
			   public String write( net.sf.json.JSON json, String encoding ) {
			      if( net.sf.json.JSONNull.getInstance()
			            .equals( json ) ){
			         nu.xom.Element root = null;
			         root = newElement( getRootName() == null ? getObjectName() : getRootName() );
			         root.addAttribute( new nu.xom.Attribute( "null", "true" ) );
			         nu.xom.Document doc = new nu.xom.Document( root );
			         return writeDocument( doc, encoding );
			      }else if( json instanceof net.sf.json.JSONArray ){
			         net.sf.json.JSONArray jsonArray = (net.sf.json.JSONArray) json;
			         nu.xom.Element root = processJSONArray( jsonArray,
			               newElement( getRootName() == null ? getArrayName() : getRootName() ),
			               expandableProperties );
			         nu.xom.Document doc = new nu.xom.Document( root );
			         return writeDocument( doc, encoding );
			      }else{
			         net.sf.json.JSONObject jsonObject = (net.sf.json.JSONObject) json;
			         nu.xom.Element root = null;
			         if( jsonObject.isNullObject() ){
			            root = newElement( getObjectName() );
			            root.addAttribute( new nu.xom.Attribute( "null", "true" ) );
			         }else{
			            root = processJSONObject( jsonObject,
			                  newElement( getRootName() == null ? getObjectName() : getRootName() ),
			                  expandableProperties, true );
			         }
			         nu.xom.Document doc = new nu.xom.Document( root );
			         return writeDocument( doc, encoding );
			      }
			   }

			   private void addNameSpaceToElement( nu.xom.Element element ) {
			      String elementName = null;
			      if( element instanceof CustomElement ){
			         elementName = ((CustomElement) element).getQName();
			      }else{
			         elementName = element.getQualifiedName();
			      }
			      java.util.Map nameSpaces = (java.util.Map) namespacesPerElement.get( elementName );
			      if( nameSpaces != null && !nameSpaces.isEmpty() ){
			         setNamespaceLenient( true );
			         for( java.util.Iterator entries = nameSpaces.entrySet()
			               .iterator(); entries.hasNext(); ){
			            java.util.Map.Entry entry = (java.util.Map.Entry) entries.next();
			            String prefix = (String) entry.getKey();
			            String uri = (String) entry.getValue();
			            if( org.apache.commons.lang.StringUtils.isBlank( prefix ) ){
			               element.setNamespaceURI( uri );
			            }else{
			               element.addNamespaceDeclaration( prefix, uri );
			            }
			         }
			      }
			   }

			   private boolean checkChildElements( nu.xom.Element element, boolean isTopLevel ) {
			      int childCount = element.getChildCount();
			      nu.xom.Elements elements = element.getChildElements();
			      int elementCount = elements.size();

			      if( childCount == 1 && element.getChild( 0 ) instanceof nu.xom.Text ){
			         return isTopLevel;
			      }

			      if( childCount == elementCount ){
			         if( elementCount == 0 ){
			            return true;
			         }
			         if( elementCount == 1 ){
			            if( element.getChild( 0 ) instanceof nu.xom.Text ){
			               return true;
			            }else{
			               return false;
			            }
			         }
			      }

			      if( childCount > elementCount ){
			         for( int i = 0; i < childCount; i++ ){
			            nu.xom.Node node = element.getChild( i );
			            if( node instanceof nu.xom.Text ){
			               nu.xom.Text text = (nu.xom.Text) node;
			               if( org.apache.commons.lang.StringUtils.isNotBlank( org.apache.commons.lang.StringUtils.strip( text.getValue() ) ) ){
			                  return false;
			               }
			            }
			         }
			      }

			      String childName = elements.get( 0 )
			            .getQualifiedName();
			      for( int i = 1; i < elementCount; i++ ){
			         if( childName.compareTo( elements.get( i )
			               .getQualifiedName() ) != 0 ){
			            return false;
			         }
			      }

			      return true;
			   }

			   private String getClass( nu.xom.Element element ) {
			      nu.xom.Attribute attribute = element.getAttribute( "class" );
			      String clazz = null;
			      if( attribute != null ){
			         String clazzText = attribute.getValue()
			               .trim();
			         if( net.sf.json.xml.JSONTypes.OBJECT.compareToIgnoreCase( clazzText ) == 0 ){
			            clazz = net.sf.json.xml.JSONTypes.OBJECT;
			         }else if( net.sf.json.xml.JSONTypes.ARRAY.compareToIgnoreCase( clazzText ) == 0 ){
			            clazz = net.sf.json.xml.JSONTypes.ARRAY;
			         }
			      }
			      return clazz;
			   }

			   private String getType( nu.xom.Element element ) {
			      return getType( element, null );
			   }

			   private String getType( nu.xom.Element element, String defaultType ) {
			      nu.xom.Attribute attribute = element.getAttribute( "type" );
			      String type = null;
			      if( attribute != null ){
			         String typeText = attribute.getValue()
			               .trim();
			         if( net.sf.json.xml.JSONTypes.BOOLEAN.compareToIgnoreCase( typeText ) == 0 ){
			            type = net.sf.json.xml.JSONTypes.BOOLEAN;
			         }else if( net.sf.json.xml.JSONTypes.NUMBER.compareToIgnoreCase( typeText ) == 0 ){
			            type = net.sf.json.xml.JSONTypes.NUMBER;
			         }else if( net.sf.json.xml.JSONTypes.INTEGER.compareToIgnoreCase( typeText ) == 0 ){
			            type = net.sf.json.xml.JSONTypes.INTEGER;
			         }else if( net.sf.json.xml.JSONTypes.FLOAT.compareToIgnoreCase( typeText ) == 0 ){
			            type = net.sf.json.xml.JSONTypes.FLOAT;
			         }else if( net.sf.json.xml.JSONTypes.OBJECT.compareToIgnoreCase( typeText ) == 0 ){
			            type = net.sf.json.xml.JSONTypes.OBJECT;
			         }else if( net.sf.json.xml.JSONTypes.ARRAY.compareToIgnoreCase( typeText ) == 0 ){
			            type = net.sf.json.xml.JSONTypes.ARRAY;
			         }else if( net.sf.json.xml.JSONTypes.STRING.compareToIgnoreCase( typeText ) == 0 ){
			            type = net.sf.json.xml.JSONTypes.STRING;
			         }else if( net.sf.json.xml.JSONTypes.FUNCTION.compareToIgnoreCase( typeText ) == 0 ){
			            type = net.sf.json.xml.JSONTypes.FUNCTION;
			         }
			      }else{
			         if( defaultType != null ){
			            log.info( "Using default type " + defaultType );
			            type = defaultType;
			         }
			      }
			      return type;
			   }

			   private boolean hasNamespaces( nu.xom.Element element ) {
			      int namespaces = 0;
			      for( int i = 0; i < element.getNamespaceDeclarationCount(); i++ ){
			         String prefix = element.getNamespacePrefix( i );
			         String uri = element.getNamespaceURI( prefix );
			         if( org.apache.commons.lang.StringUtils.isBlank( uri ) ){
			            continue;
			         }
			         namespaces++;
			      }
			      return namespaces > 0;
			   }

			   private boolean isArray( nu.xom.Element element, boolean isTopLevel ) {
			      boolean isArray = false;
			      String clazz = getClass( element );
			      if( clazz != null && clazz.equals( net.sf.json.xml.JSONTypes.ARRAY ) ){
			         isArray = true;
			      }else if( element.getAttributeCount() == 0 ){
			         isArray = checkChildElements( element, isTopLevel );
			      }else if( element.getAttributeCount() == 1
			            && (element.getAttribute( "class" ) != null || element.getAttribute( "type" ) != null) ){
			         isArray = checkChildElements( element, isTopLevel );
			      }else if( element.getAttributeCount() == 2
			            && (element.getAttribute( "class" ) != null && element.getAttribute( "type" ) != null) ){
			         isArray = checkChildElements( element, isTopLevel );
			      }

			      if( isArray ){
			         // check namespace
			         for( int j = 0; j < element.getNamespaceDeclarationCount(); j++ ){
			            String prefix = element.getNamespacePrefix( j );
			            String uri = element.getNamespaceURI( prefix );
			            if( !org.apache.commons.lang.StringUtils.isBlank( uri ) ){
			               return false;
			            }
			         }
			      }

			      return isArray;
			   }

			   private boolean isFunction( nu.xom.Element element ) {
			      int attrCount = element.getAttributeCount();
			      if( attrCount > 0 ){
			         nu.xom.Attribute typeAttr = element.getAttribute( "type" );
			         nu.xom.Attribute paramsAttr = element.getAttribute( "params" );
			         if( attrCount == 1 && paramsAttr != null ){
			            return true;
			         }
			         if( attrCount == 2 && paramsAttr != null && typeAttr != null && (typeAttr.getValue()
			               .compareToIgnoreCase( net.sf.json.xml.JSONTypes.STRING ) == 0 || typeAttr.getValue()
			               .compareToIgnoreCase( net.sf.json.xml.JSONTypes.FUNCTION ) == 0) ){
			            return true;
			         }
			      }
			      return false;
			   }

			   private boolean isNullObject( nu.xom.Element element ) {
			      if( element.getChildCount() == 0 ){
			         if( element.getAttributeCount() == 0 ){
			            return true;
			         }else if( element.getAttribute( "null" ) != null ){
			            return true;
			         }else if( element.getAttributeCount() == 1
			               && (element.getAttribute( "class" ) != null || element.getAttribute( "type" ) != null) ){
			            return true;
			         }else if( element.getAttributeCount() == 2
			               && (element.getAttribute( "class" ) != null && element.getAttribute( "type" ) != null) ){
			            return true;
			         }
			      }
			      return false;
			   }

			   private boolean isObject( nu.xom.Element element, boolean isTopLevel ) {
			      boolean isObject = false;
			      if( !isArray( element, isTopLevel ) && !isFunction( element ) ){
			         if( hasNamespaces( element ) ){
			            return true;
			         }

			         int childCount = element.getChildCount();
			         if( childCount == 1 && element.getChild( 0 ) instanceof nu.xom.Text ){
			            return isTopLevel;
			         }

			         isObject = true;
			      }
			      return isObject;
			   }

			   private nu.xom.Element newElement( String name ) {
			      if( name.indexOf( ':' ) != -1 ){
			         namespaceLenient = true;
			      }
			      return namespaceLenient ? new CustomElement( name ) : new nu.xom.Element( name );
			   }

			   private net.sf.json.JSON processArrayElement( nu.xom.Element element, String defaultType ) {
			      net.sf.json.JSONArray jsonArray = new net.sf.json.JSONArray();
			      // process children (including text)
			      int childCount = element.getChildCount();
			      for( int i = 0; i < childCount; i++ ){
			         nu.xom.Node child = element.getChild( i );
			         if( child instanceof nu.xom.Text ){
			            nu.xom.Text text = (nu.xom.Text) child;
			            if( org.apache.commons.lang.StringUtils.isNotBlank( org.apache.commons.lang.StringUtils.strip( text.getValue() ) ) ){
			               jsonArray.element( text.getValue() );
			            }
			         }else if( child instanceof nu.xom.Element ){
			            setValue( jsonArray, (nu.xom.Element) child, defaultType );
			         }
			      }
			      return jsonArray;
			   }

			   private Object processElement( nu.xom.Element element, String type ) {
			      if( isNullObject( element ) ){
			         return net.sf.json.JSONNull.getInstance();
			      }
			      if( isArray( element, false ) ){
			         return processArrayElement( element, type );
			      }else if( isObject( element, false ) ){
			         return processObjectElement( element, type );
			      }
			      if( net.sf.json.xml.JSONTypes.BOOLEAN.compareToIgnoreCase( type ) == 0 ){
			          try {
			      		return new Boolean(trimSpaceFromValue( element.getValue() ));
				      }
				      catch(Exception e) {
				      		return trimSpaceFromValue( element.getValue() );
				      }
			      }
			      else if( net.sf.json.xml.JSONTypes.NUMBER.compareToIgnoreCase( type ) == 0 ){
			          try {
			      		return new Double(trimSpaceFromValue( element.getValue() ));
				      }
				      catch(Exception e) {
				      		return trimSpaceFromValue( element.getValue() );
				      }
			      }
			      else if( net.sf.json.xml.JSONTypes.INTEGER.compareToIgnoreCase( type ) == 0 ){
			        try {
			        		return new Integer(trimSpaceFromValue( element.getValue() ));
			        }
			        catch(Exception e) {
			        		return trimSpaceFromValue( element.getValue() );
			        }
			      }
			      else if( net.sf.json.xml.JSONTypes.FLOAT.compareToIgnoreCase( type ) == 0 ){
			          try {
			      		return new Float(trimSpaceFromValue( element.getValue() ));
				      }
				      catch(Exception e) {
				      		return trimSpaceFromValue( element.getValue() );
				      }
			      }
			      else if( net.sf.json.xml.JSONTypes.STRING.compareToIgnoreCase( type ) == 0 ){
			          return trimSpaceFromValue( element.getValue() );
			      }
			      
			      else{
			         return trimSpaceFromValue( element.getValue() );
			      }
			   }

			   private nu.xom.Element processJSONArray( net.sf.json.JSONArray array, nu.xom.Element root, String[] expandableProperties ) {
			      int l = array.size();
			      for( int i = 0; i < l; i++ ){
			         Object value = array.get( i );
			         nu.xom.Element element = processJSONValue( value, root, null, expandableProperties );
			         root.appendChild( element );
			      }
			      return root;
			   }

			   private nu.xom.Element processJSONObject( net.sf.json.JSONObject jsonObject, nu.xom.Element root,
			         String[] expandableProperties, boolean isRoot ) {
			      if( jsonObject.isNullObject() ){
			         root.addAttribute( new nu.xom.Attribute( "null", "true" ) );
			         return root;
			      }else if( jsonObject.isEmpty() ){
			         return root;
			      }

			      if( isRoot ){
			         if( !rootNamespace.isEmpty() ){
			            setNamespaceLenient( true );
			            for( java.util.Iterator entries = rootNamespace.entrySet()
			                  .iterator(); entries.hasNext(); ){
			               java.util.Map.Entry entry = (java.util.Map.Entry) entries.next();
			               String prefix = (String) entry.getKey();
			               String uri = (String) entry.getValue();
			               if( org.apache.commons.lang.StringUtils.isBlank( prefix ) ){
			                  root.setNamespaceURI( uri );
			               }else{
			                  root.addNamespaceDeclaration( prefix, uri );
			               }
			            }
			         }
			      }

			      addNameSpaceToElement( root );

			      Object[] names = jsonObject.names()
			            .toArray();
			      java.util.Arrays.sort( names );
			      nu.xom.Element element = null;
			      for( int i = 0; i < names.length; i++ ){
			         String name = (String) names[i];
			         Object value = jsonObject.get( name );
			         if( name.startsWith( "@xmlns" ) ){
			            setNamespaceLenient( true );
			            int colon = name.indexOf( ':' );
			            if( colon == -1 ){
			               // do not override if already defined by nameSpaceMaps
			               if( org.apache.commons.lang.StringUtils.isBlank( root.getNamespaceURI() ) ){
			                  root.setNamespaceURI( String.valueOf( value ) );
			               }
			            }else{
			               String prefix = name.substring( colon + 1 );
			               if( org.apache.commons.lang.StringUtils.isBlank( root.getNamespaceURI( prefix ) ) ){
			                  root.addNamespaceDeclaration( prefix, String.valueOf( value ) );
			               }
			            }
			         }else if( name.startsWith( "@" ) ){
			            root.addAttribute( new nu.xom.Attribute( name.substring( 1 ), String.valueOf( value ) ) );
			         }else if( name.equals( "#text" ) ){
			            if( value instanceof net.sf.json.JSONArray ){
			               root.appendChild( ((net.sf.json.JSONArray) value).join( "", true ) );
			            }else{
			               root.appendChild( String.valueOf( value ) );
			            }
			         }else if( value instanceof net.sf.json.JSONArray
			               && (((net.sf.json.JSONArray) value).isExpandElements() || org.apache.commons.lang.ArrayUtils.contains(
			                     expandableProperties, name )) ){
			            net.sf.json.JSONArray array = (net.sf.json.JSONArray) value;
			            int l = array.size();
			            for( int j = 0; j < l; j++ ){
			               Object item = array.get( j );
			               element = newElement( name );
			               if( item instanceof net.sf.json.JSONObject ){
			                  element = processJSONValue( (net.sf.json.JSONObject) item, root, element,
			                        expandableProperties );
			               }else if( item instanceof net.sf.json.JSONArray ){
			                  element = processJSONValue( (net.sf.json.JSONArray) item, root, element, expandableProperties );
			               }else{
			                  element = processJSONValue( item, root, element, expandableProperties );
			               }
			               addNameSpaceToElement( element );
			               root.appendChild( element );
			            }
			         }else{
			            element = newElement( name );
			            element = processJSONValue( value, root, element, expandableProperties );
			            addNameSpaceToElement( element );
			            root.appendChild( element );
			         }
			      }
			      return root;
			   }

			   private nu.xom.Element processJSONValue( Object value, nu.xom.Element root, nu.xom.Element target,
			         String[] expandableProperties ) {
			      if( target == null ){
			         target = newElement( getElementName() );
			      }
			      if( net.sf.json.util.JSONUtils.isBoolean( value ) ){
			         if( isTypeHintsEnabled() ){
			            target.addAttribute( new nu.xom.Attribute( "type", net.sf.json.xml.JSONTypes.BOOLEAN ) );
			         }
			         target.appendChild( value.toString() );
			      }else if( net.sf.json.util.JSONUtils.isNumber( value ) ){
			         if( isTypeHintsEnabled() ){
			            target.addAttribute( new nu.xom.Attribute( "type", net.sf.json.xml.JSONTypes.NUMBER ) );
			         }
			         target.appendChild( value.toString() );
			      }else if( net.sf.json.util.JSONUtils.isFunction( value ) ){
			         if( value instanceof String ){
			            value = net.sf.json.JSONFunction.parse( (String) value );
			         }
			         net.sf.json.JSONFunction func = (net.sf.json.JSONFunction) value;
			         if( isTypeHintsEnabled() ){
			            target.addAttribute( new nu.xom.Attribute( "type", net.sf.json.xml.JSONTypes.FUNCTION ) );
			         }
			         String params = org.apache.commons.lang.ArrayUtils.toString( func.getParams() );
			         params = params.substring( 1 );
			         params = params.substring( 0, params.length() - 1 );
			         target.addAttribute( new nu.xom.Attribute( "params", params ) );
			         target.appendChild( new nu.xom.Text( "<![CDATA[" + func.getText() + "]]>" ) );
			      }else if( net.sf.json.util.JSONUtils.isString( value ) ){
			         if( isTypeHintsEnabled() ){
			            target.addAttribute( new nu.xom.Attribute( "type", net.sf.json.xml.JSONTypes.STRING ) );
			         }
			         target.appendChild( value.toString() );
			      }else if( value instanceof net.sf.json.JSONArray ){
			         if( isTypeHintsEnabled() ){
			            target.addAttribute( new nu.xom.Attribute( "class", net.sf.json.xml.JSONTypes.ARRAY ) );
			         }
			         target = processJSONArray( (net.sf.json.JSONArray) value, target, expandableProperties );
			      }else if( value instanceof net.sf.json.JSONObject ){
			         if( isTypeHintsEnabled() ){
			            target.addAttribute( new nu.xom.Attribute( "class", net.sf.json.xml.JSONTypes.OBJECT ) );
			         }
			         target = processJSONObject( (net.sf.json.JSONObject) value, target, expandableProperties, false );
			      }else if( net.sf.json.util.JSONUtils.isNull( value ) ){
			         if( isTypeHintsEnabled() ){
			            target.addAttribute( new nu.xom.Attribute( "class", net.sf.json.xml.JSONTypes.OBJECT ) );
			         }
			         target.addAttribute( new nu.xom.Attribute( "null", "true" ) );
			      }
			      return target;
			   }

			   private net.sf.json.JSON processObjectElement( nu.xom.Element element, String defaultType ) {
			      if( isNullObject( element ) ){
			         return net.sf.json.JSONNull.getInstance();
			      }
			      net.sf.json.JSONObject jsonObject = new net.sf.json.JSONObject();

			      if( !skipNamespaces ){
			         for( int j = 0; j < element.getNamespaceDeclarationCount(); j++ ){
			            String prefix = element.getNamespacePrefix( j );
			            String uri = element.getNamespaceURI( prefix );
			            if( org.apache.commons.lang.StringUtils.isBlank( uri ) ){
			               continue;
			            }
			            if( !org.apache.commons.lang.StringUtils.isBlank( prefix ) ){
			               prefix = ":" + prefix;
			            }
			            setOrAccumulate( jsonObject, "@xmlns" + prefix, trimSpaceFromValue( uri ) );
			         }
			      }

			      // process attributes first
			      int attrCount = element.getAttributeCount();
			      for( int i = 0; i < attrCount; i++ ){
			         nu.xom.Attribute attr = element.getAttribute( i );
			         String attrname = attr.getQualifiedName();
			         if( "class".compareToIgnoreCase( attrname ) == 0
			               || "type".compareToIgnoreCase( attrname ) == 0 ){
			            continue;
			         }
			         String attrvalue = attr.getValue();
			         setOrAccumulate( jsonObject, "@" + removeNamespacePrefix( attrname ),
			               trimSpaceFromValue( attrvalue ) );
			      }

			      // process children (including text)
			      int childCount = element.getChildCount();
			      for( int i = 0; i < childCount; i++ ){
			         nu.xom.Node child = element.getChild( i );
			         if( child instanceof nu.xom.Text ){
			            nu.xom.Text text = (nu.xom.Text) child;
			            if( org.apache.commons.lang.StringUtils.isNotBlank( org.apache.commons.lang.StringUtils.strip( text.getValue() ) ) ){
			               setOrAccumulate( jsonObject, "#text", trimSpaceFromValue( text.getValue() ) );
			            }
			         }else if( child instanceof nu.xom.Element ){
			            setValue( jsonObject, (nu.xom.Element) child, defaultType );
			         }
			      }

			      return jsonObject;
			   }

			   private String removeNamespacePrefix( String name ) {
			      if( isRemoveNamespacePrefixFromElements() ){
			         int colon = name.indexOf( ':' );
			         return colon != -1 ? name.substring( colon + 1 ) : name;
			      }
			      return name;
			   }

			   private void setOrAccumulate( net.sf.json.JSONObject jsonObject, String key, Object value ) {
			      if( jsonObject.has( key ) ){
			         jsonObject.accumulate( key, value );
			         Object val = jsonObject.get( key );
			         if( val instanceof net.sf.json.JSONArray ){
			            ((net.sf.json.JSONArray) val).setExpandElements( true );
			         }
			      }else{
			         jsonObject.element( key, value );
			      }
			   }

			   private void setValue( net.sf.json.JSONArray jsonArray, nu.xom.Element element, String defaultType ) {
			      String clazz = getClass( element );
			      String type = getType( element );
			      type = (type == null) ? defaultType : type;

			      if( hasNamespaces( element ) && !skipNamespaces ){
			         jsonArray.element( simplifyValue( null, processElement( element, type ) ) );
			         return;
			      }else if( element.getAttributeCount() > 0 ){
			         if( isFunction( element ) ){
			            nu.xom.Attribute paramsAttribute = element.getAttribute( "params" );
			            String[] params = null;
			            String text = element.getValue();
			            params = org.apache.commons.lang.StringUtils.split( paramsAttribute.getValue(), "," );
			            jsonArray.element( new net.sf.json.JSONFunction( params, text ) );
			            return;
			         }else{
			            jsonArray.element( simplifyValue( null, processElement( element, type ) ) );
			            return;
			         }
			      }

			      boolean classProcessed = false;
			      if( clazz != null ){
			         if( clazz.compareToIgnoreCase( net.sf.json.xml.JSONTypes.ARRAY ) == 0 ){
			            jsonArray.element( processArrayElement( element, type ) );
			            classProcessed = true;
			         }else if( clazz.compareToIgnoreCase( net.sf.json.xml.JSONTypes.OBJECT ) == 0 ){
			            jsonArray.element( simplifyValue( null, processObjectElement( element, type ) ) );
			            classProcessed = true;
			         }
			      }
			      if( !classProcessed ){
			         if( type.compareToIgnoreCase( net.sf.json.xml.JSONTypes.BOOLEAN ) == 0 ){
			            jsonArray.element( Boolean.valueOf( element.getValue() ) );
			         }else if( type.compareToIgnoreCase( net.sf.json.xml.JSONTypes.NUMBER ) == 0 ){
			            // try integer first
			            try{
			               jsonArray.element( Integer.valueOf( element.getValue() ) );
			            }catch( NumberFormatException e ){
			               jsonArray.element( Double.valueOf( element.getValue() ) );
			            }
			         }else if( type.compareToIgnoreCase( net.sf.json.xml.JSONTypes.INTEGER ) == 0 ){
			            jsonArray.element( Integer.valueOf( element.getValue() ) );
			         }else if( type.compareToIgnoreCase( net.sf.json.xml.JSONTypes.FLOAT ) == 0 ){
			            jsonArray.element( Double.valueOf( element.getValue() ) );
			         }else if( type.compareToIgnoreCase( net.sf.json.xml.JSONTypes.FUNCTION ) == 0 ){
			            String[] params = null;
			            String text = element.getValue();
			            nu.xom.Attribute paramsAttribute = element.getAttribute( "params" );
			            if( paramsAttribute != null ){
			               params = org.apache.commons.lang.StringUtils.split( paramsAttribute.getValue(), "," );
			            }
			            jsonArray.element( new net.sf.json.JSONFunction( params, text ) );
			         }else if( type.compareToIgnoreCase( net.sf.json.xml.JSONTypes.STRING ) == 0 ){
			            // see if by any chance has a 'params' attribute
			            nu.xom.Attribute paramsAttribute = element.getAttribute( "params" );
			            if( paramsAttribute != null ){
			               String[] params = null;
			               String text = element.getValue();
			               params = org.apache.commons.lang.StringUtils.split( paramsAttribute.getValue(), "," );
			               jsonArray.element( new net.sf.json.JSONFunction( params, text ) );
			            }else{
			               if( isArray( element, false ) ){
			                  jsonArray.element( processArrayElement( element, defaultType ) );
			               }else if( isObject( element, false ) ){
			                  jsonArray.element( simplifyValue( null, processObjectElement( element,
			                        defaultType ) ) );
			               }else{
			                  jsonArray.element( trimSpaceFromValue( element.getValue() ) );
			               }
			            }
			         }
			      }
			   }

			   private void setValue( net.sf.json.JSONObject jsonObject, nu.xom.Element element, String defaultType ) {
			      String clazz = getClass( element );
			      String type = getType( element );
			      type = (type == null) ? defaultType : type;

			      String key = removeNamespacePrefix( element.getQualifiedName() );
			      if( hasNamespaces( element ) && !skipNamespaces ){
			         setOrAccumulate( jsonObject, key, simplifyValue( jsonObject,
			               processElement( element, type ) ) );
			         return;
			      }else if( element.getAttributeCount() > 0 ){
			         if( isFunction( element ) ){
			            nu.xom.Attribute paramsAttribute = element.getAttribute( "params" );
			            String[] params = null;
			            String text = element.getValue();
			            params = org.apache.commons.lang.StringUtils.split( paramsAttribute.getValue(), "," );
			            setOrAccumulate( jsonObject, key, new net.sf.json.JSONFunction( params, text ) );
			            return;
			         }else{
			            setOrAccumulate( jsonObject, key, simplifyValue( jsonObject, processElement( element,
			                  type ) ) );
			            return;
			         }
			      }

			      boolean classProcessed = false;
			      if( clazz != null ){
			         if( clazz.compareToIgnoreCase( net.sf.json.xml.JSONTypes.ARRAY ) == 0 ){
			            setOrAccumulate( jsonObject, key, processArrayElement( element, type ) );
			            classProcessed = true;
			         }else if( clazz.compareToIgnoreCase( net.sf.json.xml.JSONTypes.OBJECT ) == 0 ){
			            setOrAccumulate( jsonObject, key, simplifyValue( jsonObject, processObjectElement(
			                  element, type ) ) );
			            classProcessed = true;
			         }
			      }
			      if( !classProcessed ){
			         if( type.compareToIgnoreCase( net.sf.json.xml.JSONTypes.BOOLEAN ) == 0 ){
			            setOrAccumulate( jsonObject, key, Boolean.valueOf( element.getValue() ) );
			         }else if( type.compareToIgnoreCase( net.sf.json.xml.JSONTypes.NUMBER ) == 0 ){
			            // try integer first
			            try{
			               setOrAccumulate( jsonObject, key, Integer.valueOf( element.getValue() ) );
			            }catch( NumberFormatException e ){
			               setOrAccumulate( jsonObject, key, Double.valueOf( element.getValue() ) );
			            }
			         }else if( type.compareToIgnoreCase( net.sf.json.xml.JSONTypes.INTEGER ) == 0 ){
			            setOrAccumulate( jsonObject, key, Integer.valueOf( element.getValue() ) );
			         }else if( type.compareToIgnoreCase( net.sf.json.xml.JSONTypes.FLOAT ) == 0 ){
			            setOrAccumulate( jsonObject, key, Double.valueOf( element.getValue() ) );
			         }else if( type.compareToIgnoreCase( net.sf.json.xml.JSONTypes.FUNCTION ) == 0 ){
			            String[] params = null;
			            String text = element.getValue();
			            nu.xom.Attribute paramsAttribute = element.getAttribute( "params" );
			            if( paramsAttribute != null ){
			               params = org.apache.commons.lang.StringUtils.split( paramsAttribute.getValue(), "," );
			            }
			            setOrAccumulate( jsonObject, key, new net.sf.json.JSONFunction( params, text ) );
			         }else if( type.compareToIgnoreCase( net.sf.json.xml.JSONTypes.STRING ) == 0 ){
			            // see if by any chance has a 'params' attribute
			            nu.xom.Attribute paramsAttribute = element.getAttribute( "params" );
			            if( paramsAttribute != null ){
			               String[] params = null;
			               String text = element.getValue();
			               params = org.apache.commons.lang.StringUtils.split( paramsAttribute.getValue(), "," );
			               setOrAccumulate( jsonObject, key, new net.sf.json.JSONFunction( params, text ) );
			            }else{
			               if( isArray( element, false ) ){
			                  setOrAccumulate( jsonObject, key, processArrayElement( element, defaultType ) );
			               }else if( isObject( element, false ) ){
			                  setOrAccumulate( jsonObject, key, simplifyValue( jsonObject,
			                        processObjectElement( element, defaultType ) ) );
			               }else{
			                  setOrAccumulate( jsonObject, key, trimSpaceFromValue( element.getValue() ) );
			               }
			            }
			         }
			      }
			   }

			   private Object simplifyValue( net.sf.json.JSONObject parent, Object json ) {
			      if( json instanceof net.sf.json.JSONObject ){
			         net.sf.json.JSONObject object = (net.sf.json.JSONObject) json;
			         if( parent != null ){
			            // remove all duplicated @xmlns from child
			            for( java.util.Iterator entries = parent.entrySet()
			                  .iterator(); entries.hasNext(); ){
			               java.util.Map.Entry entry = (java.util.Map.Entry) entries.next();
			               String key = (String) entry.getKey();
			               Object value = entry.getValue();
			               if( key.startsWith( "@xmlns" ) && value.equals( object.opt( key ) ) ){
			                  object.remove( key );
			               }
			            }
			         }
			         if( object.size() == 1 && object.has( "#text" ) ){
			            return object.get( "#text" );
			         }
			      }
			      return json;
			   }

			   private String trimSpaceFromValue( String value ) {
			      if( isTrimSpaces() ){
			         return value.trim();
			      }
			      return value;
			   }

			   private String writeDocument( nu.xom.Document doc, String encoding ) {
			      java.io.ByteArrayOutputStream baos = new java.io.ByteArrayOutputStream();
			      try{
			         XomSerializer serializer = (encoding == null) ? new XomSerializer( baos )
			               : new XomSerializer( baos, encoding );
			         serializer.write( doc );
			      }catch( java.io.IOException ioe ){
			         throw new net.sf.json.JSONException( ioe );
			      }
			      return baos.toString();
			   }

			   final class CustomElement extends nu.xom.Element {
			      private  String getName( String name ) {
			         int colon = name.indexOf( ':' );
			         if( colon != -1 ){
			            return name.substring( colon + 1 );
			         }
			         return name;
			      }

			      private  String getPrefix( String name ) {
			         int colon = name.indexOf( ':' );
			         if( colon != -1 ){
			            return name.substring( 0, colon );
			         }
			         return "";
			      }

			      private String prefix;

			      public CustomElement( String name ) {
			    	  	
			    	  	super( (name.indexOf(":") > -1) ? name.substring(name.indexOf(":") + 1) : name );
			    	  	
			    	  	prefix = getPrefix( name );
			      }

			      public final String getQName() {
			         if( prefix.length() == 0 ){
			            return getLocalName();
			         }else{
			            return prefix + ":" + getLocalName();
			         }
			      }
			   }

			   final class XomSerializer extends nu.xom.Serializer {
			      public XomSerializer( java.io.OutputStream out ) {
			         super( out );
			      }

			      public XomSerializer( java.io.OutputStream out, String encoding ) throws java.io.UnsupportedEncodingException {
			         super( out, encoding );
			      }

			      protected void write( nu.xom.Text text ) throws java.io.IOException {
			         String value = text.getValue();
			         if( value.startsWith( "<![CDATA[" ) && value.endsWith( "]]>" ) ){
			            value = value.substring( 9 );
			            value = value.substring( 0, value.length() - 3 );
			            writeRaw( "<![CDATA[" );
			            writeRaw( value );
			            writeRaw( "]]>" );
			         }else{
			            super.write( text );
			         }
			      }

			      protected void writeEmptyElementTag( nu.xom.Element element ) throws java.io.IOException {
			         if( element instanceof CustomElement && isNamespaceLenient() ){
			            writeTagBeginning( (CustomElement) element );
			            writeRaw( "/>" );
			         }else{
			            super.writeEmptyElementTag( element );
			         }
			      }

			      protected void writeEndTag( nu.xom.Element element ) throws java.io.IOException {
			         if( element instanceof CustomElement && isNamespaceLenient() ){
			            writeRaw( "</" );
			            writeRaw( ((CustomElement) element).getQName() );
			            writeRaw( ">" );
			         }else{
			            super.writeEndTag( element );
			         }
			      }

			      protected void writeNamespaceDeclaration( String prefix, String uri ) throws java.io.IOException {
			         if( !org.apache.commons.lang.StringUtils.isBlank( uri ) ){
			            super.writeNamespaceDeclaration( prefix, uri );
			         }
			      }

			      protected void writeStartTag( nu.xom.Element element ) throws java.io.IOException {
			         if( element instanceof CustomElement && isNamespaceLenient() ){
			            writeTagBeginning( (CustomElement) element );
			            writeRaw( ">" );
			         }else{
			            super.writeStartTag( element );
			         }
			      }

			      private void writeTagBeginning( CustomElement element ) throws java.io.IOException {
			         writeRaw( "<" );
			         writeRaw( element.getQName() );
			         writeAttributes( element );
			         writeNamespaceDeclarations( element );
			      }
			   }
			}


	<%
    List<IMetadataTable> metadatas = node.getMetadataList();
  	if(metadatas != null && metadatas.size() > 0){
      	IMetadataTable metadata = metadatas.get(0);
      	if(metadata != null){
		%>
		
		<%if(version_3_5_X) {%>
			com.mongodb.MongoClient mongo_<%=cid%>=null;
			com.mongodb.client.MongoDatabase db_<%=cid%>=null;
		<%} else {%>
			com.mongodb.Mongo mongo_<%=cid%>=null;
			com.mongodb.DB db_<%=cid%>=null;
		<%}%>
		
			<%
      		if (useExistingConnection){
      			String connection = ElementParameterParser.getValue(node, "__CONNECTION__");
				%>
				
				<%if(version_3_5_X) {%>
				mongo_<%=cid%>=(com.mongodb.MongoClient)globalMap.get("mongo_<%=connection%>");
				db_<%=cid%> = (com.mongodb.client.MongoDatabase) globalMap.get("db_<%=connection%>");
				<%} else {%>
				mongo_<%=cid%>=(com.mongodb.Mongo)globalMap.get("mongo_<%=connection%>");
				db_<%=cid%> = (com.mongodb.DB) globalMap.get("db_<%=connection%>");
				<%}%>
				
				<%
				if(isLog4jEnabled){
				%>	
					log.info("<%=cid%> - Get an existing client from " + "<%=connection%>" + ".");
					log.info("<%=cid%> - Get an existing DB from " + "<%=connection%>" + ".");
				<%
				}
			}else{
			%>
				<%
	 			List<Map<String,String>> replicaAddrs= (List<Map<String,String>>)ElementParameterParser.getObjectValue(node, "__REPLICA_SET__");
		        boolean useSSL = "true".equalsIgnoreCase(ElementParameterParser.getValue(node, "__USE_SSL__"));

		        String mongoDbDriver = "com.mongodb.MongoClient";

		        %>
            <%if(isLog4jEnabled){%>
			java.util.logging.Logger.getLogger("org.mongodb.driver").setLevel(java.util.logging.Level.OFF);
			<%}else{%>
			java.util.logging.Logger.getLogger("org.mongodb.driver").setLevel(java.util.logging.Level.SEVERE);
          <%}%>
                // Empty client options
                com.mongodb.MongoClientOptions clientOptions_<%=cid%> = new com.mongodb.MongoClientOptions.Builder().build();
                <%
                if (useSSL) {
                    %>
                    clientOptions_<%=cid%> = new com.mongodb.MongoClientOptions.Builder()
                    .socketFactory(javax.net.ssl.SSLSocketFactory.getDefault())
                    .build();
                    <%
                }
                
                // Client Credentials
                %>
                // Empty client credentials list
                java.util.List<com.mongodb.MongoCredential> mongoCredentialList_<%=cid%> = new java.util.ArrayList<com.mongodb.MongoCredential>();

                <%
                // Authentication
                if (authentication){
                    %>
                    com.mongodb.MongoCredential mongoCredential_<%=cid%>;
                    <%
                    if((authenticationMechanism.equals("NEGOTIATE_MEC"))||(authenticationMechanism.equals("PLAIN_MEC"))||(authenticationMechanism.equals("SCRAMSHA1_MEC"))){
                        String passwordFieldName = "__PASSWORD__";
                        %>
                        <%@ include file="@{org.talend.designer.components.localprovider}/components/templates/password.javajet"%>
                        <%
                        if(authenticationMechanism.equals("NEGOTIATE_MEC")){
                			if(dbversion.equals("MONGODB_3_0_X") || dbversion.equals("MONGODB_3_2_X") || version_3_5_X) {
%>
                    			mongoCredential_<%=cid%> = com.mongodb.MongoCredential.createCredential(<%=dbuser%>, <%=usedAuthenticationDB%>, new String(decryptedPassword_<%=cid%>).toCharArray());
<%                    
                			} else {
%>
                    			mongoCredential_<%=cid%> = com.mongodb.MongoCredential.createMongoCRCredential(<%=dbuser%>, <%=usedAuthenticationDB%>, new String(decryptedPassword_<%=cid%>).toCharArray());
<%
			                }
                        } else if(authenticationMechanism.equals("PLAIN_MEC")){
                            %>
                            mongoCredential_<%=cid%> = com.mongodb.MongoCredential.createPlainCredential(<%=dbuser%>, "$external", new String(decryptedPassword_<%=cid%>).toCharArray());
                            <%
                        } else if(authenticationMechanism.equals("SCRAMSHA1_MEC")){
                            %>
                            mongoCredential_<%=cid%> = com.mongodb.MongoCredential.createScramSha1Credential(<%=dbuser%>, <%=usedAuthenticationDB%>, new String(decryptedPassword_<%=cid%>).toCharArray());
                            <%
                        }
                    } else { // GSSAPI SASL (KERBEROS)
                        %>
                        System.setProperty("java.security.krb5.realm", <%=krbRealm%>);
                        System.setProperty("java.security.krb5.kdc", <%=krbKdc%>);
                        System.setProperty("javax.security.auth.useSubjectCredsOnly", "false");
                        mongoCredential_<%=cid%> = com.mongodb.MongoCredential.createGSSAPICredential(<%=krbUserPrincipal%>);
                        <%
                    }
                    %>
                    mongoCredentialList_<%=cid%>.add(mongoCredential_<%=cid%>);
                    <%
                }

                // the client
                if(useReplicaSet){
                    %>
                    List<com.mongodb.ServerAddress> addrs_<%=cid%> = new java.util.ArrayList<com.mongodb.ServerAddress>();
                    <%
                    for(Map<String,String> replicaAddr:replicaAddrs){
                    %>
                        addrs_<%=cid%>.add(new com.mongodb.ServerAddress(<%=replicaAddr.get("REPLICA_HOST")%>,<%=replicaAddr.get("REPLICA_PORT")%>));
                    <%
                    }
                    %>
                    mongo_<%=cid%> = new <%=mongoDbDriver%>(addrs_<%=cid%>, mongoCredentialList_<%=cid%>, clientOptions_<%=cid%>);
                    <%
                }else{
                    %>
                    com.mongodb.ServerAddress serverAddress_<%=cid%> = new com.mongodb.ServerAddress(<%=dbhost%>, <%=dbport%>);
                    mongo_<%=cid%> = new <%=mongoDbDriver%>(serverAddress_<%=cid%>, mongoCredentialList_<%=cid%>, clientOptions_<%=cid%>);
                    <%
                }
                %>
				resourceMap.put("mongo_<%=cid%>", mongo_<%=cid%>);
				<%if(version_3_5_X) {%>
					db_<%=cid%> = mongo_<%=cid%>.getDatabase(<%=dbname%>);
				<%} else {%>
					db_<%=cid%> = mongo_<%=cid%>.getDB(<%=dbname%>);
				<%}%>
				<%
			}

			if(queryOptionNoTimeOut){
		        %>
		        mongo_<%=cid%>.addOption(com.mongodb.Bytes.QUERYOPTION_NOTIMEOUT);
		        <%
    		}

			if(setWriteConcern){
				%>
				mongo_<%=cid%>.setWriteConcern(com.mongodb.WriteConcern.<%=writeConcern%>);
				<%
			}

			if(isLog4jEnabled){
			%>	
				log.info("<%=cid%> - Connecting to " + mongo_<%=cid%>.getServerAddressList() + ".");
			<%
			}
			if(dropExistCollection){
			%>
				<%if(version_3_5_X) {%>
					db_<%=cid%>.getCollection(<%=collection%>).drop();
				<%} else {%>
				if(db_<%=cid%>.collectionExists(<%=collection%>)){
					db_<%=cid%>.getCollection(<%=collection%>).drop();
				}
				<%}%>

			<%
			}
			%>
				<%if(version_3_5_X) {%>
					com.mongodb.client.MongoCollection<org.bson.Document> coll_<%=cid%> = db_<%=cid%>.getCollection(<%=collection%>);
				<%} else {%>
					com.mongodb.DBCollection coll_<%=cid%> = db_<%=cid%>.getCollection(<%=collection%>);
				<%}%>

			<%
			// BulkWrite
			if(bulkWrite){
			%>
			int bulkWriteOperationCounter_<%=cid%> = 1;
			int bulkWriteOperationSize_<%=cid%> = Integer.parseInt(<%=bulkWriteOperationSize%>);
				<%if(version_3_5_X) {
					if("INSERT".equalsIgnoreCase(dataAction)){%>
						List<com.mongodb.client.model.InsertOneModel<org.bson.Document>> bulkWriteOperation_<%=cid%> = new java.util.ArrayList<com.mongodb.client.model.InsertOneModel<org.bson.Document>>();
					<%}else if("UPSERT".equalsIgnoreCase(dataAction)||"UPDATE".equalsIgnoreCase(dataAction)){%>
						List<com.mongodb.client.model.ReplaceOneModel<org.bson.Document>> bulkWriteOperation_<%=cid%> = new java.util.ArrayList<com.mongodb.client.model.ReplaceOneModel<org.bson.Document>>();
					<%}else if("DELETE".equalsIgnoreCase(dataAction)){%>
						List<com.mongodb.client.model.DeleteOneModel<org.bson.Document>> bulkWriteOperation_<%=cid%> = new java.util.ArrayList<com.mongodb.client.model.DeleteOneModel<org.bson.Document>>();
					<%}else { //update set upset_with_set
					%>
						List<com.mongodb.client.model.UpdateOneModel<org.bson.Document>> bulkWriteOperation_<%=cid%> = new java.util.ArrayList<com.mongodb.client.model.UpdateOneModel<org.bson.Document>>();
					<%}%>
					
				<%} else {%>
					com.mongodb.BulkWriteOperation bulkWriteOperation_<%=cid%> = coll_<%=cid%>.initialize<%=bulkWriteType%>BulkOperation();
				<%}%>

				<%
			}

			%>
			
			/* CK: Here we have a bug in net.sf.json.xml.XMLSerializer: It converts empty / null values into empty arrays. Furthermore, if a type is provided in the JSON Tree definition, but a null / empty value is delivered, a parsing exception is thrown. The custom class is based on the current version of XMLSerializer and also removes empty values as well as null values. 
			net.sf.json.xml.XMLSerializer xmlSerializer_<%=cid%> = new net.sf.json.xml.XMLSerializer(); */
			
			MyXMLSerializer xmlSerializer_<%=cid%> = new MyXMLSerializer();
		    xmlSerializer_<%=cid%>.clearNamespaces();
		    xmlSerializer_<%=cid%>.setSkipNamespaces(true);
		    xmlSerializer_<%=cid%>.setForceTopLevelObject(<%=(removeRoot?false:true)%>);
		    xmlSerializer_<%=cid%>.setUseLongDecimals(true);
		    <%
		    INode sourceNode = node.getIncomingConnections(EConnectionType.ON_COMPONENT_OK).get(0).getSource();
			String virtualSourceCid = sourceNode.getUniqueName();
			INode startNode = NodeUtil.getSpecificStartNode(sourceNode);
			String startNodeCid = null; 
			if(startNode != null){
				startNodeCid = startNode.getUniqueName();
			} 
			IConnection nextMergeConn = NodeUtil.getNextMergeConnection(node);
			if(nextMergeConn != null && nextMergeConn.getInputId()>1 && startNodeCid != null){
			%>
				java.util.Queue<String> queue_<%=cid%> = new java.util.concurrent.ConcurrentLinkedQueue<String>();
				
				class ThreadXMLField_<%=cid%> extends Thread {
					java.util.Queue<String> queue;
					java.util.List<java.util.Map<String,String>> flows;
					java.lang.Exception lastException;
					String currentComponent;
					
					ThreadXMLField_<%=cid%>(java.util.Queue q) {
						this.queue = q;
						globalMap.put("queue_<%=virtualSourceCid%>", queue);
						lastException = null;
					}
					
					ThreadXMLField_<%=cid%>(java.util.Queue q, java.util.List<java.util.Map<String,String>> l) {
						this.queue = q;
						this.flows = l;
						lastException = null;
						globalMap.put("queue_<%=virtualSourceCid%>", queue);
						globalMap.put("flows_<%=virtualSourceCid%>", flows);
					}
					
					public java.lang.Exception getLastException() {
						return this.lastException;
					}
					public String getCurrentComponent() {
						return this.currentComponent;
					}
				
					@Override
					public void run() {
						try {
							<%=startNodeCid%>Process(globalMap);
						} catch (TalendException te) {
							this.lastException = te.getException();
							this.currentComponent = te.getCurrentComponent();
							globalMap.put("<%=cid%>_FINISH" + (this.queue==null?"":this.queue.hashCode()), "true");
						}
					}
				}
				
				ThreadXMLField_<%=cid%> txf_<%=cid%> = new ThreadXMLField_<%=cid%>(queue_<%=cid%>);
				txf_<%=cid%>.start();
			<%
			}else{
			%>
				java.util.Queue<String> queue_<%=cid%> = (java.util.Queue<String>) globalMap.get("queue_<%=cid%>");
			<%
			}
		    %>
			String readFinishMarkWithPipeId_<%=cid%> = "<%=cid%>_FINISH"+(queue_<%=cid%>==null?"":queue_<%=cid%>.hashCode());
			String str_<%=cid %> = null;
			<%
			if(isLog4jEnabled){
			%>
				log.info("<%=cid%> - Start to write data into database ["+db_<%=cid%>.getName()+"], data is generated by [<%=virtualSourceCid%>].");
			<%
			}
			%>

	         /**
             * Convert Date and Byte array in mongo DB format
             *
             */
            class MongoDBTreeConverter_<%=cid%> {

                /**
                 * header method to ease javajet implementation.
                 **/
                public void processTree(Object currentElement, String[] path, String pattern) {
                    if (currentElement instanceof <%=objectType%>) {
                        // Start index at 1, in order to remove the first unwanted or empty string.
                        processTree((<%=objectType%>)currentElement, path, 1, pattern);
                   } else if (currentElement instanceof com.mongodb.BasicDBList) {
                       // Start index at 1, in order to remove the first unwanted or empty string.
                       processTree((com.mongodb.BasicDBList) currentElement, path, 1, pattern);
                   }
                }

                public void processTree(<%=objectType%> currentElement, String[] path, int index, String pattern) {
                    if (index  < path.length - 1) {
                        Object nextElement = currentElement.get(path[index]);
                        if (nextElement instanceof <%=objectType%>) {
                             processTree((<%=objectType%>)nextElement, path, index + 1, pattern);
                        } else if (nextElement instanceof com.mongodb.BasicDBList) {
                            processTree((com.mongodb.BasicDBList) nextElement, path, index + 1, pattern);
                        } else if (nextElement == null && index > 0) {
                            // some loop are not reported by the XML tree
                            nextElement = currentElement.get(path[index - 1]);
                            if (nextElement != null) {
                                if (nextElement instanceof <%=objectType%>) {
                                    processTree((<%=objectType%>)nextElement, path, index, pattern);
                               } else if (nextElement instanceof com.mongodb.BasicDBList) {
                                   processTree((com.mongodb.BasicDBList) nextElement, path, index, pattern);
                               }
                            }
                        }
                    } else {
                        // process leaf
                        if (currentElement.get(path[path.length - 1]) instanceof com.mongodb.BasicDBList) {
                            // if the leaf is a list
                            com.mongodb.BasicDBList finalObjects = (com.mongodb.BasicDBList) currentElement.get(path[path.length - 1]);
                            com.mongodb.BasicDBList convertedElements = new com.mongodb.BasicDBList();
                            for (Object finalObject: finalObjects) {
                                if (pattern == null) {
                                    // no pattern, we want to parse to a byte array.
                                    if (finalObject != null) {
								                                convertedElements.add(
								                                        ((String)finalObject).getBytes());
                                    }
                                } else {
                                    if (finalObject != null) {
                                        convertedElements.add(
                                                ParserUtils.parseTo_Date((String)finalObject,
                                                        pattern));
                                    }
                                }
                            }
                            finalObjects.clear();
                            finalObjects.addAll(convertedElements);
                        } else {
                            if (pattern == null) {
                                // no pattern, we want to parse to a byte array.
                                if (currentElement.get(path[path.length - 1]) != null) {
								                            currentElement.put(path[path.length - 1],
								                                    ((String)currentElement.get(path[path.length - 1])).getBytes());
                                }
                            } else {
                                if (currentElement.get(path[path.length - 1]) != null) {
                                    currentElement.put(path[path.length - 1],
                                            ParserUtils.parseTo_Date((String)(currentElement).get(path[path.length - 1]),
                                                    pattern));
                                }
                            }
                        }
                    }
                }

                public void processTree(com.mongodb.BasicDBList currentElements, String[] path, int index, String pattern) {
                    if (index  < path.length - 1) {
                        for (Object currentElement: currentElements) {
                            if (currentElement instanceof <%=objectType%>) {
                                processTree((<%=objectType%>)currentElement, path, index + 1, pattern);
                            } else if (currentElement instanceof com.mongodb.BasicDBList) {
                                processTree((com.mongodb.BasicDBList) currentElement, path, index + 1, pattern);
                            }
                        }
                    } else {
                        // process leaf
                        com.mongodb.BasicDBList convertedElements = new com.mongodb.BasicDBList();
                        for (Object finalObject: currentElements) {
                            if (finalObject instanceof <%=objectType%>) {
                                <%=objectType%> currentElement = (<%=objectType%>) finalObject;
                                if (pattern == null) {
                                    // no pattern, we want to parse to a byte array.
                                    if (currentElement.get(path[path.length - 1]) != null) {
								                                currentElement.put(path[path.length - 1],
								                                        ((String)currentElement.get(path[path.length - 1])).getBytes());
                                    }
                                } else {
                                    if (currentElement.get(path[path.length - 1]) != null) {
                                        currentElement.put(path[path.length - 1],
                                                ParserUtils.parseTo_Date((String)(currentElement).get(path[path.length - 1]),
                                                        pattern));
                                    }
                                }
                            } else { // loop with raw types
                                if (pattern == null) {
                                    // no pattern, we want to parse to a byte array.
                                    if (finalObject != null) {
								                                convertedElements.add(
								                                        ((String)finalObject).getBytes());
                                    }
                                } else {
                                    if (finalObject != null) {
                                        convertedElements.add(
                                                ParserUtils.parseTo_Date((String)finalObject,
                                                        pattern));
                                    }
                                }
                            }
                        }
                        if (convertedElements.size() > 0) {
                            currentElements.clear();
                            currentElements.addAll(convertedElements);
                        }
                    }

                }
            }
            MongoDBTreeConverter_<%=cid%> mongoDBTreeConverter_<%=cid%> = new MongoDBTreeConverter_<%=cid%>();
			while(!globalMap.containsKey(readFinishMarkWithPipeId_<%=cid%>) || !queue_<%=cid%>.isEmpty()) {
				if (!queue_<%=cid%>.isEmpty()) {
					str_<%=cid %> = queue_<%=cid %>.poll();
					//Convert XML to JSON
			        net.sf.json.JSON json_<%=cid%> = xmlSerializer_<%=cid%>.read(str_<%=cid %>);
			        json_<%=cid%> = xmlSerializer_<%=cid%>.removeEmptyAndNullValues(json_<%=cid%>);
					nb_line_<%=cid%>++;

		<%
    	}
    }
	%>